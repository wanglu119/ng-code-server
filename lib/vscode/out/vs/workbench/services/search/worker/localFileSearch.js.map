{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/search/worker/fake","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/getFileResults.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/ignoreFile.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/worker/localFileSearch.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = 'vscode-app';\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.isWebWorker && platform.globals.origin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T>{\n\n\tprivate _size = 0;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t * An event that fires when every promise in the queue\n\t * has started to execute. In other words: no work is\n\t * pending to be scheduled.\n\t *\n\t * This is NOT an event that signals when all promises\n\t * have finished though.\n\t */\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tthis._size--;\n\t\tthis.runningPromises--;\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t} else {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueFor(resource: URI, extUri: IExtUri = defaultExtUri): ILimiter<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue;\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate _token: any;\n\n\tconstructor() {\n\t\tthis._token = -1;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearInterval(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n */\nexport let runWhenIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\ndeclare function requestIdleCallback(callback: (args: IdleDeadline) => void, options?: { timeout: number }): number;\ndeclare function cancelIdleCallback(handle: number): void;\n\n(function () {\n\tif (typeof requestIdleCallback !== 'function' || typeof cancelIdleCallback !== 'function') {\n\t\trunWhenIdle = (runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\trunner(Object.freeze({\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\trunWhenIdle = (runner, timeout?) => {\n\t\t\tconst handle: number = requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\tcancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n})();\n\n/**\n * An implementation of the \"idle-until-urgent\"-strategy as introduced\n * here: https://philipwalton.com/articles/idle-until-urgent/\n */\nexport class IdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = runWhenIdle(() => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tlet promiseResolve: () => void;\n\t\t\tlet promiseReject: (error: Error) => void;\n\t\t\tconst promise = new Promise<void>((resolve, reject) => {\n\t\t\t\tpromiseResolve = resolve;\n\t\t\t\tpromiseReject = reject;\n\t\t\t});\n\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters, ltrim } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, …)\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchResult } from 'vs/workbench/services/search/common/search';\nimport { TextSearchPreviewOptions } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { Range } from 'vs/editor/common/core/range';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tbeforeContext: number;\n\t\tafterContext: number;\n\t\tpreviewOptions: TextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndecies: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndecies.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndecies.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndecies) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.beforeContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.beforeContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchResult = {\n\t\t\t\tranges: fileRange,\n\t\t\t\tpreview: { text: previewText, matches: previewRange },\n\t\t\t};\n\t\t\tresults.push(match);\n\n\t\t\tif (options.afterContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.afterContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\n\n\nexport class IgnoreFile {\n\n\tprivate isPathIgnored: (path: string, isDir: boolean, parent?: IgnoreFile) => boolean;\n\n\tconstructor(\n\t\tcontents: string,\n\t\tprivate readonly location: string,\n\t\tprivate readonly parent?: IgnoreFile) {\n\t\tif (location[location.length - 1] === '\\\\') {\n\t\t\tthrow Error('Unexpected path format, do not use trailing backslashes');\n\t\t}\n\t\tif (location[location.length - 1] !== '/') {\n\t\t\tlocation += '/';\n\t\t}\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Updates the contents of the ignorefile. Preservering the location and parent\n\t * @param contents The new contents of the gitignore file\n\t */\n\tupdateContents(contents: string) {\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Returns true if a path in a traversable directory has not been ignored.\n\t *\n\t * Note: For performance reasons this does not check if the parent directories have been ignored,\n\t * so it should always be used in tandem with `shouldTraverseDir` when walking a directory.\n\t *\n\t * In cases where a path must be tested in isolation, `isArbitraryPathIncluded` should be used.\n\t */\n\tisPathIncludedInTraversal(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst ignored = this.isPathIgnored(path, isDir);\n\n\t\treturn !ignored;\n\t}\n\n\t/**\n\t * Returns true if an arbitrary path has not been ignored.\n\t * This is an expensive operation and should only be used ouside of traversals.\n\t */\n\tisArbitraryPathIgnored(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst segments = path.split('/').filter(x => x);\n\t\tlet ignored = false;\n\n\t\tlet walkingPath = '';\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst isLast = i === segments.length - 1;\n\t\t\tconst segment = segments[i];\n\n\t\t\twalkingPath = walkingPath + '/' + segment;\n\n\t\t\tif (!this.isPathIncludedInTraversal(walkingPath, isLast ? isDir : true)) {\n\t\t\t\tignored = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ignored;\n\t}\n\n\tprivate gitignoreLinesToExpression(lines: string[], dirPath: string, trimForExclusions: boolean): glob.ParsedExpression {\n\t\tconst includeLines = lines.map(line => this.gitignoreLineToGlob(line, dirPath));\n\n\t\tconst includeExpression: glob.IExpression = Object.create(null);\n\t\tfor (const line of includeLines) {\n\t\t\tincludeExpression[line] = true;\n\t\t}\n\n\t\treturn glob.parse(includeExpression, { trimForExclusions });\n\t}\n\n\n\tprivate parseIgnoreFile(ignoreContents: string, dirPath: string, parent: IgnoreFile | undefined): (path: string, isDir: boolean) => boolean {\n\t\tconst contentLines = ignoreContents\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim())\n\t\t\t.filter(line => line && line[0] !== '#');\n\n\t\t// Pull out all the lines that end with `/`, those only apply to directories\n\t\tconst fileLines = contentLines.filter(line => !line.endsWith('/'));\n\n\t\tconst fileIgnoreLines = fileLines.filter(line => !line.includes('!'));\n\t\tconst isFileIgnored = this.gitignoreLinesToExpression(fileIgnoreLines, dirPath, true);\n\n\t\t// TODO: Slight hack... this naieve approach may reintroduce too many files in cases of weirdly complex .gitignores\n\t\tconst fileIncludeLines = fileLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isFileIncluded = this.gitignoreLinesToExpression(fileIncludeLines, dirPath, false);\n\n\t\t// When checking if a dir is ignored we can use all lines\n\t\tconst dirIgnoreLines = contentLines.filter(line => !line.includes('!'));\n\t\tconst isDirIgnored = this.gitignoreLinesToExpression(dirIgnoreLines, dirPath, true);\n\n\t\t// Same hack.\n\t\tconst dirIncludeLines = contentLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isDirIncluded = this.gitignoreLinesToExpression(dirIncludeLines, dirPath, false);\n\n\t\tconst isPathIgnored = (path: string, isDir: boolean) => {\n\t\t\tif (!path.startsWith(dirPath)) { return false; }\n\t\t\tif (isDir && isDirIgnored(path) && !isDirIncluded(path)) { return true; }\n\t\t\tif (isFileIgnored(path) && !isFileIncluded(path)) { return true; }\n\n\t\t\tif (parent) { return parent.isPathIgnored(path, isDir); }\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn isPathIgnored;\n\t}\n\n\tprivate gitignoreLineToGlob(line: string, dirPath: string): string {\n\t\tconst firstSep = line.indexOf('/');\n\t\tif (firstSep === -1 || firstSep === line.length - 1) {\n\t\t\tline = '**/' + line;\n\t\t} else {\n\t\t\tif (firstSep === 0) {\n\t\t\t\tif (dirPath.slice(-1) === '/') {\n\t\t\t\t\tline = line.slice(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirPath.slice(-1) !== '/') {\n\t\t\t\t\tline = '/' + line;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = dirPath + line;\n\t\t}\n\n\t\treturn line;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\nimport { UriComponents, URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { ILocalFileSearchSimpleWorker, ILocalFileSearchSimpleWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from 'vs/workbench/services/search/common/localFileSearchWorkerTypes';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from 'vs/workbench/services/search/common/search';\nimport * as paths from 'vs/base/common/path';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { getFileResults } from 'vs/workbench/services/search/common/getFileResults';\nimport { IgnoreFile } from 'vs/workbench/services/search/common/ignoreFile';\nimport { createRegExp } from 'vs/base/common/strings';\nimport { Promises } from 'vs/base/common/async';\nimport { ExtUri } from 'vs/base/common/resources';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: ILocalFileSearchSimpleWorkerHost): IRequestHandler {\n\treturn new LocalFileSearchSimpleWorker(host);\n}\n\nexport class LocalFileSearchSimpleWorker implements ILocalFileSearchSimpleWorker, IRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(private host: ILocalFileSearchSimpleWorkerHost) { }\n\n\tcancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tafterContext: query.afterContext ?? 0,\n\t\t\t\t\tbeforeContext: query.beforeContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => any, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = glob.parse(folderQuery.excludePattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression;\n\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => any) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn {\n\t\t...folderQuery,\n\t\tfolder: URI.revive(folderQuery.folder),\n\t};\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","exports","$Of","code","$Pf","osPath","path_1","$Qf","$Rf","path","sep","firstLetter","pos","start","$Wf","$Sf","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","$Tf","name","isWindowsOS","invalidFileChars","$Uf","pathA","pathB","ignoreCase","identityEquals","strings_1","$Vf","base","parentCandidate","separator","sepOffset","char0","$Xf","candidate","cwd","$Yf","pathNormalized","$Zf","$1f","$2f","$3f","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","$4f","parent","prefix","randomLength","suffix","pathCharsTouse","randomFileName","Schemas","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","uri","err","errors","query","uri_1","platform","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","value","addSearchParam","urlOrSearch","coop","coep","$gg","$hg","a","uri1","uri2","ignoreFragment","network_1","extpath","resource","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","_","$Bg","items","resourceAccessor","distinctParents","candidateResource","otherItem","index","DataUri","parseMetaData","dataUri","metadata","property","key","mime","$Cg","localScheme","$Dg","obj","$Eg","callback","source","cancellation_1","thenable","promise","resolve","reject","subscription","errors_1","onfinally","$Fg","token","defaultValue","ref","$Gg","$Hg","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","$Ig","timeout","onTimeout","promiseResolve","timer","$Jg","item","$Kg","promiseFactory","onComplete","$Lg","promiseTask","$Mg","newPromise","timeoutDeferred","fn","scheduled","handle","microtaskDeferred","$Ng","defaultDelay","task","delay","symbols_1","$Og","$Pg","c","e","$Qg","autoOpenTimeMs","$Rg","millis","disposable","$Sg","handler","store","lifecycle_1","$Tg","promiseFactories","results","next","thenHandler","n","$Ug","shouldStop","t","loop","factory","$Vg","promiseList","todo","finish","$Wg","maxDegreeOfParalellism","event_1","iLimitedTask","$Xg","$Yg","$0g","$Zg","$_g","queue","extUri","resources_1","drainListenerId","drainListener","drainer","$1g","runner","$2g","interval","$3g","$4g","$5g","unit","units","$6g","g","h","disposed","end","$8g","executor","$9g","retries","lastError","error","taskId","onCancel","queued","run","promiseReject","$$g","d","f","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","AsyncIterableSourceState","$ah","writer","emitter","iterables","iterable","mapFn","filterFn","values","$bh","l","$ch","innerIterable","$nj","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","$qj","pattern","splitChar","inBraces","inBrackets","curVal","char","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","res","braceRegExp","choice","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","parsedPattern","wrapRelativePattern","match","trivia1","trimForExclusions","trivia2","trivia3","trivia4and5","toRegExp","arg2","wrappedPattern","basename","extpath_1","slashBase","backslashBase","basenames","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","allPaths","all","current","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","regExp","$rj","hasSibling","$sj","$tj","resultPattern","parsedExpression","rp","$uj","patternOrExpression","$vj","expression","parseExpressionPattern","resultExpression","resultPromises","async_1","resultPromise","when","clausePattern","matched","basenamePatterns","patterns","aggregate","ch","aggregatedPatterns","$wj","patternsA","patternsB","arrays_1","b","$Ngc","bytes","text","patternIndecies","patternMatch","remainingResultQuota","contextLinesNeeded","resultLines","lineRanges","readLine","lineNumber","prevLineEnd","lineEndingMatch","lineEndRegex","startLine","matchStartIndex","matchedText","endLine","contextLine","previewText","offset","matchLine","previewLine","fileRange","range_1","previewRange","$LIb","contents","isDir","x","ignored","walkingPath","isLast","lines","dirPath","includeLines","includeExpression","glob","ignoreContents","contentLines","fileLines","fileIgnoreLines","isFileIgnored","fileIncludeLines","isFileIncluded","dirIgnoreLines","isDirIgnored","dirIncludeLines","isDirIncluded","firstSep","PERF","globalStart","itrcount","time","itr","r","create","LocalFileSearchSimpleWorker","queryId","folderQuery","ignorePathCasing","revivedFolderQuery","reviveFolderQuery","entries","limitHit","count","max","filePatternMatcher","reviveQueryProps","file","revivedQuery","createSearchRegExp","onGoingProcesses","fileCount","resultCount","processFile","fileResults","getFileResults_1","queryProps","onFile","folderExcludes","isFolderExcluded","pathExcludedInQuery","pathIncludedInQuery","prior","isFileSystemDirectoryHandle","isFileSystemFileHandle","processDirectory","directory","ignoreFile","ignoreFiles","ignoreFile_1","files","dirs","sibilings","entry","resolveDirectory","processed","fq","fsPath","searchPath","relPath"],"file":"localFileSearch.js"}